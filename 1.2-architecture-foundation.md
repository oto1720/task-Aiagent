# Phase 1.2: アーキテクチャ基盤構築 詳細手順

TimeFlowアプリのClean Architecture基盤を構築し、Riverpod状態管理、ルーティング、エラーハンドリングを設定します。

## 前提条件

- Phase 1.1が完了していること
- 依存関係がすべてインストール済み
- Firebase設定が完了していること

## 1. Clean Architectureの基盤実装

### 1.1 ディレクトリ構造の作成

以下のコマンドで必要なディレクトリを作成：

```bash
# core配下
mkdir -p lib/core/constants
mkdir -p lib/core/errors
mkdir -p lib/core/utils
mkdir -p lib/core/config

# data配下
mkdir -p lib/data/datasources/local
mkdir -p lib/data/datasources/remote
mkdir -p lib/data/datasources/ai
mkdir -p lib/data/models/user
mkdir -p lib/data/models/task
mkdir -p lib/data/models/schedule
mkdir -p lib/data/models/analytics
mkdir -p lib/data/repositories

# domain配下
mkdir -p lib/domain/entities
mkdir -p lib/domain/repositories
mkdir -p lib/domain/usecases/auth
mkdir -p lib/domain/usecases/task_management
mkdir -p lib/domain/usecases/schedule_generation
mkdir -p lib/domain/usecases/analytics
mkdir -p lib/domain/usecases/calendar_integration

# presentation配下（既存のpageをリネーム）
mkdir -p lib/presentation/pages/auth
mkdir -p lib/presentation/pages/settings
mkdir -p lib/presentation/widgets/common
mkdir -p lib/presentation/widgets/task
mkdir -p lib/presentation/widgets/schedule
mkdir -p lib/presentation/widgets/timer
mkdir -p lib/presentation/widgets/analytics
mkdir -p lib/presentation/providers

# services配下
mkdir -p lib/services/ai
mkdir -p lib/services/notification
mkdir -p lib/services/calendar
mkdir -p lib/services/storage
mkdir -p lib/services/analytics
```

### 1.2 コア定数の定義

`lib/core/constants/app_constants.dart` を作成：

```dart
class AppConstants {
  // アプリ情報
  static const String appName = 'TimeFlow';
  static const String appVersion = '1.0.0';
  
  // Firebase Collections
  static const String usersCollection = 'users';
  static const String tasksCollection = 'tasks';
  static const String schedulesCollection = 'schedules';
  static const String analyticsCollection = 'analytics';
  
  // Storage Keys
  static const String userProfileKey = 'user_profile';
  static const String settingsKey = 'app_settings';
  static const String cacheKey = 'cache_data';
  
  // API Endpoints
  static const String baseUrl = 'https://api.timeflow.app';
  static const Duration apiTimeout = Duration(seconds: 30);
  
  // UI Constants
  static const double defaultPadding = 16.0;
  static const double defaultRadius = 12.0;
  static const double defaultSpacing = 8.0;
  
  // Task Categories
  static const List<String> defaultCategories = [
    '仕事',
    '勉強',
    '運動',
    '家事',
    'その他',
  ];
  
  // Timer Settings
  static const int defaultPomodoroMinutes = 25;
  static const int defaultShortBreakMinutes = 5;
  static const int defaultLongBreakMinutes = 15;
}
```

### 1.3 アプリ設定クラス

`lib/core/config/app_config.dart` を作成：

```dart
import 'package:flutter/foundation.dart';

class AppConfig {
  static const bool isDebugMode = kDebugMode;
  static const bool enableAnalytics = true;
  static const bool enableCrashReporting = true;
  
  // Environment specific settings
  static String get apiBaseUrl {
    if (kDebugMode) {
      return 'https://dev-api.timeflow.app';
    }
    return 'https://api.timeflow.app';
  }
  
  static String get firebaseProjectId {
    if (kDebugMode) {
      return 'timeflow-dev';
    }
    return 'timeflow-prod';
  }
}
```

### 1.4 エラー定義

`lib/core/errors/exceptions.dart` を作成：

```dart
abstract class AppException implements Exception {
  final String message;
  final String code;
  
  const AppException(this.message, this.code);
}

class ServerException extends AppException {
  const ServerException(super.message, super.code);
}

class NetworkException extends AppException {
  const NetworkException(super.message, super.code);
}

class CacheException extends AppException {
  const CacheException(super.message, super.code);
}

class AuthException extends AppException {
  const AuthException(super.message, super.code);
}

class ValidationException extends AppException {
  const ValidationException(super.message, super.code);
}
```

`lib/core/errors/failures.dart` を作成：

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'failures.freezed.dart';

@freezed
class Failure with _$Failure {
  const factory Failure.server({
    required String message,
    required String code,
  }) = ServerFailure;
  
  const factory Failure.network({
    required String message,
    required String code,
  }) = NetworkFailure;
  
  const factory Failure.cache({
    required String message,
    required String code,
  }) = CacheFailure;
  
  const factory Failure.auth({
    required String message,
    required String code,
  }) = AuthFailure;
  
  const factory Failure.validation({
    required String message,
    required String code,
  }) = ValidationFailure;
  
  const factory Failure.unknown({
    required String message,
    required String code,
  }) = UnknownFailure;
}
```

### 1.5 ユーティリティクラス

`lib/core/utils/logger.dart` を作成：

```dart
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';

enum LogLevel { debug, info, warning, error }

class Logger {
  static void log(
    String message, {
    LogLevel level = LogLevel.info,
    String? tag,
    Object? error,
    StackTrace? stackTrace,
  }) {
    if (!kDebugMode && level == LogLevel.debug) return;
    
    final String formattedMessage = tag != null ? '[$tag] $message' : message;
    
    switch (level) {
      case LogLevel.debug:
        developer.log(formattedMessage, name: 'DEBUG');
        break;
      case LogLevel.info:
        developer.log(formattedMessage, name: 'INFO');
        break;
      case LogLevel.warning:
        developer.log(formattedMessage, name: 'WARNING');
        break;
      case LogLevel.error:
        developer.log(
          formattedMessage,
          name: 'ERROR',
          error: error,
          stackTrace: stackTrace,
        );
        break;
    }
  }
  
  static void debug(String message, {String? tag}) {
    log(message, level: LogLevel.debug, tag: tag);
  }
  
  static void info(String message, {String? tag}) {
    log(message, level: LogLevel.info, tag: tag);
  }
  
  static void warning(String message, {String? tag}) {
    log(message, level: LogLevel.warning, tag: tag);
  }
  
  static void error(
    String message, {
    String? tag,
    Object? error,
    StackTrace? stackTrace,
  }) {
    log(
      message,
      level: LogLevel.error,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
    );
  }
}
```

`lib/core/utils/validators.dart` を作成：

```dart
class Validators {
  static String? email(String? value) {
    if (value == null || value.isEmpty) {
      return 'メールアドレスを入力してください';
    }
    
    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    if (!emailRegex.hasMatch(value)) {
      return '有効なメールアドレスを入力してください';
    }
    
    return null;
  }
  
  static String? password(String? value) {
    if (value == null || value.isEmpty) {
      return 'パスワードを入力してください';
    }
    
    if (value.length < 8) {
      return 'パスワードは8文字以上で入力してください';
    }
    
    return null;
  }
  
  static String? required(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldNameを入力してください';
    }
    return null;
  }
  
  static String? taskName(String? value) {
    return required(value, 'タスク名');
  }
  
  static String? positiveNumber(String? value, String fieldName) {
    if (value == null || value.isEmpty) {
      return '$fieldNameを入力してください';
    }
    
    final number = int.tryParse(value);
    if (number == null || number <= 0) {
      return '$fieldNameは正の数値で入力してください';
    }
    
    return null;
  }
}
```

## 2. Riverpod状態管理の初期設定

### 2.1 基本プロバイダーの設定

`lib/presentation/providers/app_providers.dart` を作成：

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'app_providers.g.dart';

// アプリ初期化状態
@riverpod
class AppInitialization extends _$AppInitialization {
  @override
  Future<bool> build() async {
    // Firebase初期化やその他の初期設定
    await Future.delayed(const Duration(seconds: 2)); // 模擬初期化時間
    return true;
  }
}

// テーマ設定プロバイダー
@riverpod
class ThemeNotifier extends _$ThemeNotifier {
  @override
  bool build() {
    // SharedPreferencesから読み込み（後で実装）
    return false; // false: light, true: dark
  }
  
  void toggleTheme() {
    state = !state;
    // SharedPreferencesに保存（後で実装）
  }
}

// 言語設定プロバイダー
@riverpod
class LocaleNotifier extends _$LocaleNotifier {
  @override
  String build() {
    return 'ja'; // デフォルトは日本語
  }
  
  void setLocale(String locale) {
    state = locale;
  }
}
```

### 2.2 認証プロバイダー

`lib/presentation/providers/auth_provider.dart` を作成：

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:firebase_auth/firebase_auth.dart';

part 'auth_provider.g.dart';

// 認証状態プロバイダー
@riverpod
Stream<User?> authState(AuthStateRef ref) {
  return FirebaseAuth.instance.authStateChanges();
}

// 現在のユーザープロバイダー
@riverpod
User? currentUser(CurrentUserRef ref) {
  final authState = ref.watch(authStateProvider);
  return authState.value;
}

// 認証サービスプロバイダー
@riverpod
class AuthService extends _$AuthService {
  @override
  FutureOr<void> build() {}
  
  Future<UserCredential?> signInWithEmailAndPassword(
    String email,
    String password,
  ) async {
    try {
      state = const AsyncLoading();
      final credential = await FirebaseAuth.instance
          .signInWithEmailAndPassword(email: email, password: password);
      state = const AsyncData(null);
      return credential;
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      return null;
    }
  }
  
  Future<UserCredential?> createUserWithEmailAndPassword(
    String email,
    String password,
  ) async {
    try {
      state = const AsyncLoading();
      final credential = await FirebaseAuth.instance
          .createUserWithEmailAndPassword(email: email, password: password);
      state = const AsyncData(null);
      return credential;
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      return null;
    }
  }
  
  Future<void> signOut() async {
    try {
      state = const AsyncLoading();
      await FirebaseAuth.instance.signOut();
      state = const AsyncData(null);
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
    }
  }
}
```

### 2.3 タスクプロバイダー（基本構造）

`lib/presentation/providers/task_provider.dart` を作成：

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'task_provider.g.dart';

// タスクリストプロバイダー（後でFirestoreと連携）
@riverpod
class TaskList extends _$TaskList {
  @override
  List<Map<String, dynamic>> build() {
    return []; // 空のタスクリストで初期化
  }
  
  void addTask(Map<String, dynamic> task) {
    state = [...state, task];
  }
  
  void updateTask(String taskId, Map<String, dynamic> updatedTask) {
    state = state.map((task) {
      if (task['id'] == taskId) {
        return {...task, ...updatedTask};
      }
      return task;
    }).toList();
  }
  
  void removeTask(String taskId) {
    state = state.where((task) => task['id'] != taskId).toList();
  }
}

// 選択中のタスクプロバイダー
@riverpod
class SelectedTask extends _$SelectedTask {
  @override
  Map<String, dynamic>? build() {
    return null;
  }
  
  void selectTask(Map<String, dynamic> task) {
    state = task;
  }
  
  void clearSelection() {
    state = null;
  }
}
```

## 3. ルーティング設定

### 3.1 ルート定義

`lib/core/router/app_router.dart` を作成：

```dart
import 'package:go_router/go_router.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../presentation/pages/splash.dart';
import '../../presentation/pages/home.dart';
import '../../presentation/pages/task.dart';
import '../../presentation/pages/calendar.dart';
import '../../presentation/pages/timer.dart';
import '../../presentation/pages/statistic.dart';
import '../../presentation/pages/auth/login.dart';
import '../../presentation/pages/auth/profile_setup.dart';
import '../../presentation/pages/settings/user_profile.dart';
import '../../presentation/pages/settings/preferences.dart';
import '../../presentation/pages/settings/calendar_integration.dart';
import '../config/route_names.dart';

final goRouterProvider = Provider<GoRouter>((ref) {
  return GoRouter(
    initialLocation: RouteNames.splash,
    routes: [
      // スプラッシュ画面
      GoRoute(
        path: RouteNames.splash,
        name: 'splash',
        builder: (context, state) => const SplashPage(),
      ),
      
      // 認証関連
      GoRoute(
        path: RouteNames.login,
        name: 'login',
        builder: (context, state) => const LoginPage(),
      ),
      GoRoute(
        path: RouteNames.profileSetup,
        name: 'profile_setup',
        builder: (context, state) => const ProfileSetupPage(),
      ),
      
      // メイン画面（タブ付き）
      ShellRoute(
        builder: (context, state, child) => MainShell(child: child),
        routes: [
          GoRoute(
            path: RouteNames.home,
            name: 'home',
            builder: (context, state) => const HomePage(),
          ),
          GoRoute(
            path: RouteNames.tasks,
            name: 'tasks',
            builder: (context, state) => const TaskPage(),
          ),
          GoRoute(
            path: RouteNames.calendar,
            name: 'calendar',
            builder: (context, state) => const CalendarPage(),
          ),
          GoRoute(
            path: RouteNames.timer,
            name: 'timer',
            builder: (context, state) => const TimerPage(),
          ),
          GoRoute(
            path: RouteNames.statistics,
            name: 'statistics',
            builder: (context, state) => const StatisticPage(),
          ),
        ],
      ),
      
      // 設定関連
      GoRoute(
        path: RouteNames.userProfile,
        name: 'user_profile',
        builder: (context, state) => const UserProfilePage(),
      ),
      GoRoute(
        path: RouteNames.preferences,
        name: 'preferences',
        builder: (context, state) => const PreferencesPage(),
      ),
      GoRoute(
        path: RouteNames.calendarIntegration,
        name: 'calendar_integration',
        builder: (context, state) => const CalendarIntegrationPage(),
      ),
    ],
  );
});

// メインシェル（BottomNavigationBar付き）
class MainShell extends StatelessWidget {
  final Widget child;
  
  const MainShell({super.key, required this.child});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: child,
      bottomNavigationBar: BottomNavigationBar(
        type: BottomNavigationBarType.fixed,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'ホーム',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.task),
            label: 'タスク',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.calendar_today),
            label: 'カレンダー',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.timer),
            label: 'タイマー',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.analytics),
            label: '統計',
          ),
        ],
        onTap: (index) => _onTap(context, index),
      ),
    );
  }
  
  void _onTap(BuildContext context, int index) {
    switch (index) {
      case 0:
        context.go(RouteNames.home);
        break;
      case 1:
        context.go(RouteNames.tasks);
        break;
      case 2:
        context.go(RouteNames.calendar);
        break;
      case 3:
        context.go(RouteNames.timer);
        break;
      case 4:
        context.go(RouteNames.statistics);
        break;
    }
  }
}
```

### 3.2 ルート名定義

`lib/core/config/route_names.dart` を作成：

```dart
class RouteNames {
  // 認証・初期化
  static const String splash = '/';
  static const String login = '/login';
  static const String profileSetup = '/profile-setup';
  
  // メイン画面
  static const String home = '/home';
  static const String tasks = '/tasks';
  static const String calendar = '/calendar';
  static const String timer = '/timer';
  static const String statistics = '/statistics';
  
  // 設定
  static const String userProfile = '/settings/profile';
  static const String preferences = '/settings/preferences';
  static const String calendarIntegration = '/settings/calendar';
  
  // タスク関連（詳細画面など）
  static const String taskDetail = '/tasks/:id';
  static const String taskEdit = '/tasks/:id/edit';
  static const String taskCreate = '/tasks/create';
}
```

### 3.3 認証ガードの追加

`lib/core/router/auth_guard.dart` を作成：

```dart
import 'package:go_router/go_router.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../presentation/providers/auth_provider.dart';
import '../config/route_names.dart';

final authGuardProvider = Provider<AuthGuard>((ref) {
  return AuthGuard(ref);
});

class AuthGuard {
  final Ref ref;
  
  AuthGuard(this.ref);
  
  String? redirect(BuildContext context, GoRouterState state) {
    final user = ref.read(currentUserProvider);
    final isLoggedIn = user != null;
    
    final isAuthRoute = state.location == RouteNames.login || 
                       state.location == RouteNames.profileSetup;
    
    // 未認証でメイン画面にアクセスしようとした場合
    if (!isLoggedIn && !isAuthRoute && state.location != RouteNames.splash) {
      return RouteNames.login;
    }
    
    // 認証済みで認証画面にアクセスしようとした場合
    if (isLoggedIn && isAuthRoute) {
      return RouteNames.home;
    }
    
    return null; // リダイレクトなし
  }
}
```

## 4. エラーハンドリング機構

### 4.1 グローバルエラーハンドラー

`lib/core/errors/error_handler.dart` を作成：

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../utils/logger.dart';
import 'failures.dart';

final errorHandlerProvider = Provider<ErrorHandler>((ref) {
  return ErrorHandler();
});

class ErrorHandler {
  void handleError(Object error, StackTrace stackTrace) {
    Logger.error(
      'Unhandled error occurred',
      error: error,
      stackTrace: stackTrace,
      tag: 'ErrorHandler',
    );
    
    // 必要に応じてクラッシュレポーティングサービスに送信
    // FirebaseCrashlytics.instance.recordError(error, stackTrace);
  }
  
  String getErrorMessage(Failure failure) {
    return failure.when(
      server: (message, code) => 'サーバーエラーが発生しました: $message',
      network: (message, code) => 'ネットワークエラーが発生しました',
      cache: (message, code) => 'データの読み込みに失敗しました',
      auth: (message, code) => '認証エラーが発生しました: $message',
      validation: (message, code) => '入力内容を確認してください: $message',
      unknown: (message, code) => '予期しないエラーが発生しました',
    );
  }
  
  void showErrorDialog(BuildContext context, Failure failure) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('エラー'),
        content: Text(getErrorMessage(failure)),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
  
  void showErrorSnackBar(BuildContext context, Failure failure) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(getErrorMessage(failure)),
        backgroundColor: Colors.red,
        action: SnackBarAction(
          label: '閉じる',
          textColor: Colors.white,
          onPressed: () => ScaffoldMessenger.of(context).hideCurrentSnackBar(),
        ),
      ),
    );
  }
}
```

### 4.2 Result型の実装

`lib/core/utils/result.dart` を作成：

```dart
import 'package:freezed_annotation/freezed_annotation.dart';
import '../errors/failures.dart';

part 'result.freezed.dart';

@freezed
class Result<T> with _$Result<T> {
  const factory Result.success(T data) = Success<T>;
  const factory Result.failure(Failure failure) = FailureResult<T>;
  
  // 便利メソッド
  bool get isSuccess => this is Success<T>;
  bool get isFailure => this is FailureResult<T>;
  
  T? get data => when(
    success: (data) => data,
    failure: (_) => null,
  );
  
  Failure? get failure => when(
    success: (_) => null,
    failure: (failure) => failure,
  );
}

// 拡張メソッド
extension ResultExtensions<T> on Result<T> {
  Result<U> map<U>(U Function(T) transform) {
    return when(
      success: (data) => Result.success(transform(data)),
      failure: (failure) => Result.failure(failure),
    );
  }
  
  Future<Result<U>> asyncMap<U>(Future<U> Function(T) transform) async {
    return when(
      success: (data) async {
        try {
          final result = await transform(data);
          return Result.success(result);
        } catch (error) {
          return Result.failure(
            Failure.unknown(
              message: error.toString(),
              code: 'TRANSFORM_ERROR',
            ),
          );
        }
      },
      failure: (failure) => Future.value(Result.failure(failure)),
    );
  }
}
```

### 4.3 AsyncValue拡張

`lib/core/utils/async_value_extensions.dart` を作成：

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter/material.dart';
import '../errors/failures.dart';

extension AsyncValueExtensions<T> on AsyncValue<T> {
  Widget when({
    required Widget Function(T data) data,
    required Widget Function() loading,
    required Widget Function(Failure failure) error,
  }) {
    return this.when(
      data: data,
      loading: loading,
      error: (err, stack) {
        final failure = err is Failure 
            ? err 
            : Failure.unknown(
                message: err.toString(),
                code: 'UNKNOWN_ERROR',
              );
        return error(failure);
      },
    );
  }
}
```

## 5. メインアプリの更新

### 5.1 main.dartの更新

`lib/main.dart` を更新：

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';
import 'core/router/app_router.dart';
import 'presentation/providers/app_providers.dart';
import 'core/errors/error_handler.dart';
import 'core/utils/logger.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // Firebase初期化
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  
  // エラーハンドリングの設定
  FlutterError.onError = (FlutterErrorDetails details) {
    Logger.error(
      'Flutter error occurred',
      error: details.exception,
      stackTrace: details.stack,
      tag: 'FlutterError',
    );
  };
  
  runApp(
    const ProviderScope(
      child: TimeFlowApp(),
    ),
  );
}

class TimeFlowApp extends ConsumerWidget {
  const TimeFlowApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(goRouterProvider);
    final isDarkMode = ref.watch(themeNotifierProvider);
    
    return MaterialApp.router(
      title: 'TimeFlow',
      theme: ThemeData(
        useMaterial3: true,
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: isDarkMode ? Brightness.dark : Brightness.light,
        ),
      ),
      routerConfig: router,
      debugShowCheckedModeBanner: false,
    );
  }
}
```

## 6. プレースホルダーページの作成

認証関連とその他の画面のプレースホルダーを作成：

### 6.1 認証画面

`lib/presentation/pages/auth/login.dart`：

```dart
import 'package:flutter/material.dart';

class LoginPage extends StatelessWidget {
  const LoginPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ログイン')),
      body: const Center(
        child: Text('ログインページ（Phase 1.3で実装）'),
      ),
    );
  }
}
```

`lib/presentation/pages/auth/profile_setup.dart`：

```dart
import 'package:flutter/material.dart';

class ProfileSetupPage extends StatelessWidget {
  const ProfileSetupPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('プロフィール設定')),
      body: const Center(
        child: Text('プロフィール設定ページ（Phase 1.3で実装）'),
      ),
    );
  }
}
```

### 6.2 設定画面

`lib/presentation/pages/settings/user_profile.dart`：

```dart
import 'package:flutter/material.dart';

class UserProfilePage extends StatelessWidget {
  const UserProfilePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ユーザープロフィール')),
      body: const Center(
        child: Text('ユーザープロフィールページ（後で実装）'),
      ),
    );
  }
}
```

`lib/presentation/pages/settings/preferences.dart`：

```dart
import 'package:flutter/material.dart';

class PreferencesPage extends StatelessWidget {
  const PreferencesPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('設定')),
      body: const Center(
        child: Text('設定ページ（後で実装）'),
      ),
    );
  }
}
```

`lib/presentation/pages/settings/calendar_integration.dart`：

```dart
import 'package:flutter/material.dart';

class CalendarIntegrationPage extends StatelessWidget {
  const CalendarIntegrationPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('カレンダー連携')),
      body: const Center(
        child: Text('カレンダー連携ページ（Phase 5で実装）'),
      ),
    );
  }
}
```

## 7. コード生成とテスト

### 7.1 コード生成の実行

```bash
# Freezedやその他のコード生成を実行
flutter packages pub run build_runner build --delete-conflicting-outputs
```

### 7.2 基本テスト実行

```bash
# 静的解析
flutter analyze

# テスト実行
flutter test

# アプリ起動確認
flutter run
```

## 8. 動作確認チェックリスト

- [ ] アプリが正常に起動する
- [ ] スプラッシュ画面が表示される
- [ ] BottomNavigationBarで画面切り替えができる
- [ ] 各画面にプレースホルダーが表示される
- [ ] エラーが発生していない
- [ ] ホットリロードが正常に動作する

## 9. トラブルシューティング

### よくある問題と解決方法

1. **コード生成エラー**
   ```bash
   flutter packages pub run build_runner clean
   flutter packages pub run build_runner build --delete-conflicting-outputs
   ```

2. **Riverpodプロバイダーエラー**
   - `part` ディレクティブが正しいか確認
   - アノテーションが正しく付与されているか確認

3. **ルーティングエラー**
   - RouteNames定数が正しいか確認
   - 画面ファイルのインポートパスが正しいか確認

4. **Firebase接続エラー**
   ```bash
   flutterfire configure --force
   ```

## 10. 次のステップ

Phase 1.2完了後、以下に進みます：

- **Phase 1.3**: 認証システムの詳細実装
- **Phase 2.1**: タスク管理機能の実装

各フェーズの詳細手順書も必要に応じて作成可能です。